# Задание онлайн-хакатона «Оптимальный маршрут»
![main](https://github.com/RFPanda/Optimal-route/blob/main/Assets/IMG1.png)
## Формулировка задания
Реализовать программу решения транспортной задачи с применением технологий
параллельного программирования на языке C#. Подробнее в файле [Задание.pdf](https://github.com/RFPanda/Optimal-route/blob/main/Assets/Задание.pdf)
## Определение транспортной задачи
Определение транспортной задачи
Транспортная задача – это математическая задача по нахождению оптимального
распределения поставок товара между пунктами отправления и назначения при заданных, численно выраженных затратах на перевозку. Транспортная задача может быть представлена в виде прямоугольной таблицы. Пример такой записи для конкретной транспортной задачи:
![image](https://github.com/user-attachments/assets/39ed282e-f111-43dc-9ce6-6837bd2dc8d7)
Цена перевозки (например, в рублях за 1 килограмм груза) Cij записывается в ячейки таблицы на пересечении соответствующего потребителя и поставщика. Искомой величиной в задаче являются такие объемы перевозки Xij от поставщиков к потребителям, чтобы минимизировать общие затраты на транспортировку (i =1, N; j =1, M ; N – число поставщиков, M – число потребителей).
## Входные данные
Входные данные
Исходные данные для программы представлены в текстовом файле (in.txt) в виде N+3
строк целочисленных значений, разделенных пробелом, где:
• первая строка содержит N и M;
• вторая строка содержит запасы поставщиков А1, А2, …, АN;
• третья строка содержит потребности потребителей B1, B2, …, BM; 
• оставшиеся строки представляют цены перевозок в формате:
C11  C12  … C1M 
C21  C22  … C2M
…
CN1  CN2  … CNM
Входной файл для вышеуказанной таблицы см. [по ссылке](https://csharpcooking.github.io/data/Hackathon/in.txt).
## Выходные данные
Выходные данные программы должны быть представлены в текстовом файле
(out.txt) в виде N+1 строк целочисленных значений, разделенных пробелом, где: • первая строка содержит суммарные затраты на перевозки товаров;
• остальные строки представляют объемы перевозок в формате:
X11  X12  … X1M 
X21  X22  … X2M
…
XN1  XN2  … XNM
Пример такого выходного файла для вышеуказанной таблицы см. [по ссылке](https://csharpcooking.github.io/data/Hackathon/out.txt).
## Тестирование программ
Для тестирования будет применяться библиотека BenchmarkDotNet и целевая
платформа с характеристиками:
• 2 × Intel Xeon CPU E5-2640 0 2.50GHz, 24 логических, 12 физических ядра;
• ОП: DDR3 128 GBytes с 4-х канальным режимом работы;
• ОС: Windows 10 (10.0.14393.2248/1607/AnniversaryUpdate/Redstone1), 
• Runtime=.NET 9.0.0, X64 RyuJIT AVX.
Более подробные характеристики узла см. [тут](https://csharpcooking.github.io/data/Hackathon/NodeCharacteristics.txt).
## Критерии оценивания
- Скорость достижения результата;
- Минимальные затраты на перевозки товаров.

# Решение
## Используемые средства: 
- FrameworkDisplayName = ".NET Framework 4.8"
- Microsoft Visual Studio v14.38.33135.00
- Intel(R) Core(TM) i5-8300H CPU @ 2.30 GHz
- Motherboard ASUSTeK X580GD
- Graphics NVIDIA GeForce GTX 1050 GDDR5 4 GB
- Samsung DDR4-2400 (SO-DIMM) RAM 12,0 GB; 17 clocks; 1200MHz
## Скачивание проекта
Для удобства скачивания решение представлено в виде архива [DownloadMe.zip](https://github.com/RFPanda/Optimal-route/blob/main/DownlodMe.zip)
## Метод решения задачи
Транспортная задача — это математическая задача по нахождению оптимального распределения поставок однородного «товара» (груза, вещества) между пунктами отправления и назначения при заданных, численно выраженных затратах (стоимостях, расходах) на перевозку. Общее решение изначально описано методами линейной алгебры, как для задачи линейного программирования специального вида. Транспортная задача может быть представлена на письме в виде прямоугольной таблицы.
Существуют несколько методов решения данной задачи: 

> - Метод северо-западного угла
> - Метод минимальных тарифов
> - Метод Фогеля
> - Метод потенциалов

Для решения данной задачи был выбран `метод Фогеля`. Данный метод состоит в вычислении для каждой строки транспортной таблицы разницы между двумя наименьшими тарифами. Аналогичное действие выполняют для каждого столбца этой таблицы. Наибольшая разница между двумя минимальными тарифами соответствует наиболее предпочтительной строке или столбцу (если есть несколько строк или столбцов с одинаковой разницей, то выбор между ними произволен). В пределах этой строки или столбца отыскивают ячейку с минимальным тарифом, куда пишут отгрузку. Строки поставщиков или столбцы потребителей, которые полностью исчерпали свои возможности по отгрузке или потребности которых в товаре были удовлетворены, вычеркиваются из таблицы (в примерах ниже они закрашиваются серым цветом), и вычисление повторяются до полного удовлетворения спроса и исчерпания отгрузок без учета вычеркнутых («серых») ячеек.
## Запуск проекта
- Запустить и протестировать проект можно как в самой среде Microsoft Visual Studio, так и постредством скомпилированного .exe файла [Optimal route.exe](https://github.com/RFPanda/Optimal-route/blob/main/App/bin/Release/Optimal%20route.exe)
- Входной файл [in.txt](https://github.com/RFPanda/Optimal-route/blob/main/App/bin/Release/in.txt) должен располагаться в директории .../App/bin/Release/ рядом с исполняемым .exe файлом.
- Выходой файл [out.txt](https://github.com/RFPanda/Optimal-route/blob/main/App/bin/Release/out.txt) формируется автоматически в директории .../App/bin/Release/, а также имеет свойство перезаписывания в случае смены входного файла in.txt.
## Код программы
```
using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
// Khasanov Ainur | Solved 01.12.2024 for KAI | khasanov.000.pe 
class TransportTaskByKhasanovA
{
    public static void Main(string[] args)
    {
        string inputFile = "in.txt";  // Входной файл с данными
        string outputFile = "out.txt"; // Выходной файл для результатов
        // Чтение входных данных из файла
        var input = File.ReadAllLines(inputFile);
        var sizes = input[0].Split().Select(int.Parse).ToArray();
        int n = sizes[0]; // Количество поставщиков
        int m = sizes[1]; // Количество потребителей
        // Чтение запасов поставщиков и потребностей потребителей
        var supplies = input[1].Split().Select(int.Parse).ToArray();  // Чтение запасов
        var demands = input[2].Split().Select(int.Parse).ToArray(); // Чтение потребностей 
        // Чтение стоимости перевозки
        var costs = new int[n, m];
        for (int i = 0; i < n; i++)
        {
            var row = input[3 + i].Split().Select(int.Parse).ToArray();
            for (int j = 0; j < m; j++)
            {
                costs[i, j] = row[j];
            }
        }
        var DaBydetReshenye = VogelMethodbyKhasanovA(n, m, supplies, demands, costs); // Методом Фогеля
        File.WriteAllLines(outputFile, DaBydetReshenye.Select(row => string.Join(" ", row)));// Записываем результат в файл
    }

    /*
    Метод Фогеля состоит в вычислении для каждой строки транспортной таблицы разницы между двумя наименьшими тарифами. 
    Аналогичное действие выполняют для каждого столбца этой таблицы. 
    Наибольшая разница между двумя минимальными тарифами соответствует наиболее предпочтительной строке или столбцу 
    (если есть несколько строк или столбцов с одинаковой разницей, то выбор между ними произволен). 
    В пределах этой строки или столбца отыскивают ячейку с минимальным тарифом, куда пишут отгрузку. 
    Строки поставщиков или столбцы потребителей, которые полностью исчерпали свои возможности по отгрузке или потребности которых в товаре были удовлетворены, вычеркиваются из таблицы 
    (в примерах ниже они закрашиваются серым цветом), и вычисление повторяются до полного удовлетворения спроса и исчерпания отгрузок без учета вычеркнутых («серых») ячеек.
    Штраф — разница между минимальными тарифами в строке или столбце, который помогает выбрать, куда следует сделать следующую отгрузку, чтобы минимизировать общие затраты.
    */

    private static int[][] VogelMethodbyKhasanovA(int n, int m, int[] supplies, int[] demands, int[,] costs) // Методом Фогеля
    {
        int[][] solution = new int[n][]; // массив для решения задачи
        for (int i = 0; i < n; i++)
        {
            solution[i] = new int[m];
        }
        int totalCost = 0; // Суммарная стоимость перевозок totalCost
        // Параллельный расчет штрафов для строк и столбцов
        while (supplies.Sum() > 0 && demands.Sum() > 0)
        {
            var rowAndColumnPenalties = new (int Penalty, int RowOrCol, bool IsRow)[n + m]; // Массив, который будет содержать штрафы для строк и столбцов
            // Параллельный расчет штрафов для строк и столбцов
            Parallel.For(0, n + m, k =>
            {
                if (k < n && supplies[k] > 0) // Штраф для строк
                {
                    // Выбираем минимальные и вторые минимальные значения стоимости для строки
                    var rowCosts = Enumerable.Range(0, m)
                        .Where(j => demands[j] > 0) // Только для тех, где есть спрос
                        .Select(j => costs[k, j])
                        .OrderBy(x => x)
                        .ToArray();
                    rowAndColumnPenalties[k] = (rowCosts.Length > 1 ? rowCosts[1] - rowCosts[0] : rowCosts[0], k, true);// Вычисляем разницу между минимальными тарифами
                }
                else if (k >= n && demands[k - n] > 0) // Штраф для столбцов
                {
                    var colCosts = Enumerable.Range(0, n)
                        .Where(i => supplies[i] > 0) // Только для тех, где есть поставки
                        .Select(i => costs[i, k - n])
                        .OrderBy(x => x)
                        .ToArray();
                    // Вычисляем разницу
                    rowAndColumnPenalties[k] = (colCosts.Length > 1 ? colCosts[1] - colCosts[0] : colCosts[0], k - n, false);
                }
            });
            // Выбираем максимальный штраф для дальнейшего распределения
            var maxPenalty = rowAndColumnPenalties.Where(p => p.Penalty >= 0).OrderByDescending(p => p.Penalty).First();
            int row = maxPenalty.IsRow ? maxPenalty.RowOrCol : -1;
            int col = maxPenalty.IsRow ? -1 : maxPenalty.RowOrCol;
            // Выбираем минимальную стоимость для строки или столбца с максимальным штрафом
            if (maxPenalty.IsRow)
            {
                col = Enumerable.Range(0, m)
                    .Where(j => demands[j] > 0) // Только для потребителей, где есть спрос
                    .OrderBy(j => costs[row, j]) // Сортируем по стоимости
                    .First();
            }
            else
            {
                row = Enumerable.Range(0, n)
                    .Where(i => supplies[i] > 0) // Только для поставщиков, где есть поставки
                    .OrderBy(i => costs[i, col]) // Сортируем по стоимости
                    .First();
            }
            int amount = Math.Min(supplies[row], demands[col]); // Распределяем минимальное количество товара
            solution[row][col] = amount; // Обновляем решение
            totalCost += amount * costs[row, col]; // Добавляем к суммарной стоимости
            supplies[row] -= amount; // Уменьшаем запас поставщика
            demands[col] -= amount; // Уменьшаем потребность потребителя
        }
        // Результат
        var DaBydetReshenye = new int[n + 1][];
        DaBydetReshenye[0] = new[] { totalCost };
        for (int i = 0; i < n; i++)
        {
            DaBydetReshenye[i + 1] = solution[i];
        }
        return DaBydetReshenye;
    }
}
```
